import os
import time
import requests
import random
from datetime import datetime
from urllib.parse import urlparse
from colorama import init

class VulnerabilityScanner:
    def __init__(self):
        self.payload_dir = os.path.join(os.path.dirname(__file__), 'payloads')
        self.user_agents = self._load_user_agents()
        init(autoreset=True)

    def _load_user_agents(self):
        user_agents_file = os.path.join(self.payload_dir, 'user_agents.txt')
        try:
            with open(user_agents_file, 'r') as f:
                return [line.strip() for line in f if line.strip()]
        except:
            return ['Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36']

    def _load_payloads(self, payload_file):
        file_path = os.path.join(self.payload_dir, payload_file)
        try:
            with open(file_path, 'r', encoding='utf-8') as f:
                return [line.strip() for line in f if line.strip()]
        except Exception as e:
            raise Exception(f"Error loading payloads: {str(e)}")

    def _get_random_user_agent(self):
        return random.choice(self.user_agents)

    def _generate_scan_summary(self, results, scan_type):
        domain = urlparse(results['target_url']).netloc
        summary = {
            'scan_info': {
                'target_domain': domain,
                'scan_type': scan_type,
                'scan_date': datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
                'scan_duration': f"{results['scan_time']:.2f} seconds",
                'total_tests_performed': results['total_scanned'],
                'vulnerabilities_found': results['total_found']
            },
            'risk_level': self._calculate_risk_level(results),
            'quick_summary': self._generate_quick_summary(results, scan_type),
            'detailed_findings': results['vulnerabilities'],
            'recommendations': self._generate_recommendations(results, scan_type)
        }
        return summary

    def _calculate_risk_level(self, results):
        if results['total_found'] == 0:
            return {
                'level': 'Low',
                'description': 'No significant vulnerabilities were detected during the scan.'
            }
        elif results['total_found'] <= 2:
            return {
                'level': 'Medium',
                'description': 'Some vulnerabilities were detected that should be addressed.'
            }
        else:
            return {
                'level': 'High',
                'description': 'Multiple critical vulnerabilities were detected that require immediate attention.'
            }

    def _generate_quick_summary(self, results, scan_type):
        if results['total_found'] == 0:
            return f"No {scan_type} vulnerabilities were detected in the target website."
        else:
            return f"Detected {results['total_found']} potential {scan_type} vulnerabilities that require attention."

    def _generate_recommendations(self, results, scan_type):
        recommendations = {
            'LFI': [
                "Implement proper input validation and sanitization",
                "Use whitelisting for allowed file paths",
                "Avoid passing user-supplied input to file system operations",
                "Implement proper access controls and file permissions"
            ],
            'SQL': [
                "Use parameterized queries or prepared statements",
                "Implement input validation and sanitization",
                "Use an ORM (Object-Relational Mapping) framework",
                "Limit database user privileges",
                "Enable proper error handling to prevent SQL error disclosure"
            ],
            'XSS': [
                "Implement proper input validation and sanitization",
                "Use Content Security Policy (CSP) headers",
                "Encode output data properly",
                "Use modern framework's built-in XSS protection"
            ],
            'OR': [
                "Implement proper URL validation",
                "Use a whitelist of allowed redirect destinations",
                "Avoid passing user input directly to redirect functions",
                "Implement indirect object references for redirection"
            ],
            'CRLF': [
                "Sanitize user input to remove CR and LF characters",
                "Use proper output encoding",
                "Implement strict input validation for headers",
                "Use secure framework functions for setting headers"
            ]
        }
        return recommendations.get(scan_type, ["No specific recommendations available."])

    def run_lfi_scanner(self, target_url):
        payloads = self._load_payloads('lfi_payloads.txt')
        results = {
            'target_url': target_url,
            'vulnerabilities': [],
            'total_scanned': 0,
            'total_found': 0,
            'scan_time': 0
        }
        
        start_time = time.time()
        
        for payload in payloads:
            try:
                url = f"{target_url}{payload}"
                response = requests.get(
                    url, 
                    headers={'User-Agent': self._get_random_user_agent()},
                    timeout=10,
                    verify=False
                )
                
                results['total_scanned'] += 1
                
                if 'root:' in response.text or '/etc/passwd' in response.text:
                    vulnerability = {
                        'type': 'Local File Inclusion',
                        'url': url,
                        'payload_used': payload,
                        'severity': 'High',
                        'description': 'The application appears to be vulnerable to Local File Inclusion attacks.',
                        'potential_impact': [
                            'Unauthorized access to sensitive files',
                            'Information disclosure',
                            'System file exposure'
                        ],
                        'evidence': 'Successfully accessed system files using directory traversal',
                        'discovered_at': datetime.now().strftime("%Y-%m-%d %H:%M:%S")
                    }
                    results['vulnerabilities'].append(vulnerability)
                    results['total_found'] += 1
                    
            except Exception as e:
                continue
                
        results['scan_time'] = time.time() - start_time
        return self._generate_scan_summary(results, 'LFI')

    def run_sql_scanner(self, target_url):
        payloads = self._load_payloads('sql_payloads.txt')
        results = {
            'target_url': target_url,
            'vulnerabilities': [],
            'total_scanned': 0,
            'total_found': 0,
            'scan_time': 0
        }
        
        start_time = time.time()
        
        for payload in payloads:
            try:
                url = f"{target_url}{payload}"
                start_request_time = time.time()
                response = requests.get(
                    url, 
                    headers={'User-Agent': self._get_random_user_agent()},
                    timeout=10,
                    verify=False
                )
                request_time = time.time() - start_request_time
                
                results['total_scanned'] += 1
                
                vulnerability = None
                
                # Time-based detection
                if request_time > 5:
                    vulnerability = {
                        'type': 'SQL Injection (Time-based)',
                        'url': url,
                        'payload_used': payload,
                        'severity': 'High',
                        'description': 'The application appears to be vulnerable to time-based SQL injection attacks.',
                        'potential_impact': [
                            'Unauthorized database access',
                            'Data manipulation',
                            'Information disclosure'
                        ],
                        'evidence': f'Unusual response time detected ({request_time:.2f} seconds)',
                        'discovered_at': datetime.now().strftime("%Y-%m-%d %H:%M:%S")
                    }
                    results['vulnerabilities'].append(vulnerability)
                    results['total_found'] += 1
                
                # Error-based detection
                if any(error in response.text.lower() for error in ['sql', 'mysql', 'postgresql', 'oracle']):
                    vulnerability = {
                        'type': 'SQL Injection (Error-based)',
                        'url': url,
                        'payload_used': payload,
                        'severity': 'High',
                        'description': 'The application appears to be vulnerable to error-based SQL injection attacks.',
                        'potential_impact': [
                            'Unauthorized database access',
                            'Data manipulation',
                            'Information disclosure'
                        ],
                        'evidence': 'SQL error message detected in response',
                        'discovered_at': datetime.now().strftime("%Y-%m-%d %H:%M:%S")
                    }
                    results['vulnerabilities'].append(vulnerability)
                    results['total_found'] += 1
                    
            except Exception as e:
                continue
                
        results['scan_time'] = time.time() - start_time
        return self._generate_scan_summary(results, 'SQL')

    def run_xss_scanner(self, target_url):
        payloads = self._load_payloads('xss_payloads.txt')
        results = {
            'target_url': target_url,
            'vulnerabilities': [],
            'total_scanned': 0,
            'total_found': 0,
            'scan_time': 0
        }
        
        start_time = time.time()
        
        for payload in payloads:
            try:
                url = f"{target_url}{quote(payload)}"
                response = requests.get(
                    url, 
                    headers={'User -Agent': self._get_random_user_agent()},
                    timeout=10,
                    verify=False
                )
                
                results['total_scanned'] += 1
                
                if payload in response.text:
                    vulnerability = {
                        'type': 'Cross-Site Scripting (XSS)',
                        'url': url,
                        'payload_used': payload,
                        'severity': 'High',
                        'description': 'The application appears to be vulnerable to XSS attacks.',
                        'potential_impact': [
                            'Session hijacking',
                            'Defacement',
                            'Malware distribution'
                        ],
                        'evidence': 'Payload reflected in response',
                        'discovered_at': datetime.now().strftime("%Y-%m-%d %H:%M:%S")
                    }
                    results['vulnerabilities'].append(vulnerability)
                    results['total_found'] += 1
                    
            except Exception as e:
                continue
                
        results['scan_time'] = time.time() - start_time
        return self._generate_scan_summary(results, 'XSS')

    def run_or_scanner(self, target_url):
        payloads = self._load_payloads('or_payloads.txt')
        results = {
            'target_url': target_url,
            'vulnerabilities': [],
            'total_scanned': 0,
            'total_found': 0,
            'scan_time': 0
        }
        
        start_time = time.time()
        
        for payload in payloads:
            try:
                url = f"{target_url}{payload}"
                response = requests.get(
                    url, 
                    headers={'User -Agent': self._get_random_user_agent()},
                    timeout=10,
                    verify=False
                )
                
                results['total_scanned'] += 1
                
                if "redirect" in response.url.lower():
                    vulnerability = {
                        'type': 'Open Redirect',
                        'url': url,
                        'payload_used': payload,
                        'severity': 'Medium',
                        'description': 'The application appears to be vulnerable to open redirect attacks.',
                        'potential_impact': [
                            'Phishing attacks',
                            'Malware distribution'
                        ],
                        'evidence': 'Redirected to an external URL',
                        'discovered_at': datetime.now().strftime("%Y-%m-%d %H:%M:%S")
                    }
                    results['vulnerabilities'].append(vulnerability)
                    results['total_found'] += 1
                    
            except Exception as e:
                continue
                
        results['scan_time'] = time.time() - start_time
        return self._generate_scan_summary(results, 'Open Redirect')

    def run_crlf_scanner(self, target_url):
        payloads = self._load_payloads('crlf_payloads.txt')
        results = {
            'target_url': target_url,
            'vulnerabilities': [],
            'total_scanned': 0,
            'total_found': 0,
            'scan_time': 0
        }
        
       